"""
颠倒给定的 32 位无符号整数的二进制位。

提示：

请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 2中，输入表示有符号整数 -3，输出表示有符号整数 -1073741825。


示例 1：

输入：n = 00000010100101000001111010011100
输出：964176192 (00111001011110000010100101000000)
解释：输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。
示例 2：

输入：n = 11111111111111111111111111111101
输出：3221225471 (10111111111111111111111111111111)
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。


提示：
输入是一个长度为 32 的二进制字符串

"""


class Solution:
    # 逐位颠倒：我实现的官方题解
    """
    执行用时：32 ms, 在所有 Python3 提交中击败了76.23%的用户
    内存消耗：14.9 MB, 在所有 Python3 提交中击败了59.82%的用户
    """

    def reverseBits1(self, n: int) -> int:
        result = 0
        for i in range(32):
            result |= (n & 1) << (31 - i)
            n >>= 1
        return result

    # 位运算分治：我实现的官方题解
    """
    执行用时：28 ms, 在所有 Python3 提交中击败了92.27%的用户
    内存消耗：14.9 MB, 在所有 Python3 提交中击败了39.40%的用户
    """
    def reverseBits(self, n: int) -> int:
        M1 = int("01010101010101010101010101010101", 2)  # 0x55555555
        M2 = int("00110011001100110011001100110011", 2)  # 0x33333333
        M4 = int("00001111000011110000111100001111", 2)  # 0x0f0f0f0f
        M8 = int("00000000111111110000000011111111", 2)  # 0x00ff00ff
        M5 = int('00000000000000001111111111111111', 2)

        # print(n)  # 43261596      # 0000 0010 1001 0100 0001 1110 1001 1100
        n = ((n >> 1) & M1) | ((n & M1) << 1)
        # print(n)  # 23604588      # 0000 0001 0110 1000 0010 1101 0110 1100
        n = ((n >> 2) & M2) | ((n & M2) << 2)
        # print(n)  # 76711827      # 0000 0100 1001 0010 1000 0111 1001 0011
        n = ((n >> 4) & M4) | ((n & M4) << 4)
        # print(n)  # 1076459577    # 0100 0000 0010 1001 0111 1000 0011 1001
        n = ((n >> 8) & M8) | ((n & M8) << 8)
        # print(n)  # 692074872     # 0010 1001 0100 0000 0011 1001 0111 1000
        n = ((n >> 16) & M5) | ((n & M5) << 16)
        """
        print(n >> 16)
        # 14712 # 11100101111000
        print(n << 16)
        # 63188250918912    11 1001 0111 1000 0010 1001 0100 0000 0000 0000 0000 0000
        print((n >> 16) | (n << 16))
        # 63188250933624  11100101111000 0010 1001 0100 0000 0011 1001 0111 1000
        
        python只有int类型，没有int32类型，左移补0，右移去掉低位
        """

        # print(n)  # 964176192     # 0011 1001 0111 1000 0010 1001 0100 0000
        return n  # 这种交换方式很特别

    # 别人的题解:字符串
    """
    根据Python3内置函数bin的特性，'0b'会代替前边多个0
    颠倒后应在字符串前边添加上'0b'，以此来代替多个0
    颠倒后应在字符串后边添加上 '0' * (32-len(bin(n)[2:]))，以此来补充上bin() 函数返回结果中 '0b'代替的多个0
    """
    """
    执行用时：28 ms, 在所有 Python3 提交中击败了92.27%的用户
    内存消耗：14.9 MB, 在所有 Python3 提交中击败了56.14%的用户
    """

    def reverseBits3(self, n: int) -> int:
        return int('0b' + bin(n)[2:][::-1] + '0' * (32 - len(bin(n)[2:])), 2)


s = Solution()
n = "00000010100101000001111010011100"
# n = "11111111111111111111111111111101"
int_n = int(n, 2)
# print(int_n)
print(s.reverseBits(int_n))
